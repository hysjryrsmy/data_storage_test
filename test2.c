#define _CRT_SECURE_NO_WARNING
#include <stdio.h>


//任意一个二进制浮点数V可以表示成下面的形式：
// (-1)^S*M*2^E
// (-1)^S表示符号位，当s=0， V为正数； 当s=1，V为负数
// M表示有效数字，大于等于1，小于2
// 2^E表示指数位

// 举例来说: 十进制的5.0，写成二进制是101.0，相当于1.01×2^2，按照上年V的格式，可以得出s=0，M=1.01，E=2
// 十进制的-5.0，写成二进制是-101.0，相当于-1.01×2^2. 那么，s=1, M=1.01, E=2
// IEEE 754规定：对于32位的浮点数，最高的一位是符号位s，接着的8位是指数E，剩下的23位为有效数字M
// 对于64位的浮点数，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M
// E是一个无符号整数； E为8位，它的取值范围为0~255，如果E为11位，它的取值范围为0~2047，存入内存时E的真实值必须加上一个中间数
// 对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。
// 例如：2^10的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001  

// 指数E从内存中取出还可以再分成三种情况：
// 1.E不全为0或不全为1：
// 浮点数采用的规则：指数E的存储值减去127得到E的真实值，如果是double型减去1023
// 2.E全为0
// 无穷小接近于0的很小的数字
// 3.E全为1
// 表示的正负无穷大的数字






//浮点型在内存中的存储

/*
int main()
{
	double d = 1E10;
	printf("%lf\n", d);
	return 0;
}
*/  


int main()
{
	//9.0
	//二进制：1001.0
	//0 00000000 00000000000000000001001 - 补码
	
	//(-1)^0 * 1.001 * 2^3
	//(-1)^s * M     * 2^E
	//s - 0 
	//M - 1.001
	//E - 3

	int n = 9;
	float* pFloat = (float*)&n; //强制转换
	printf("n的值为：%d\n", n);
	printf("*pFloat的值为：%f\n", *pFloat);
	//(-1)^0 * 0.0000000000000000000000000001001 * 2^(-126)
	//

	*pFloat = 9.0;
	//1001.0
	//1.001*2^3
	//(-1)^0 * 1.001 * 2^3
	//0 10000010 001000000000000000000000

	printf("num的值为：%d\n", n);
	printf("*pFloat的值为： %f\n", *pFloat);
	return 0;
} 







